import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { createHash } from 'crypto';
import { spawn } from 'child_process';

/**
 * Malware scan result
 */
export interface MalwareScanResult {
  clean: boolean;
  scanned: boolean;
  scannerUsed: 'clamav' | 'virustotal' | 'disabled';
  threat?: string;
  scanDuration?: number;
  fileHash?: string;
  error?: string;
}

/**
 * Scanner configuration
 */
interface ScannerConfig {
  enabled: boolean;
  clamavEnabled: boolean;
  clamavHost: string;
  clamavPort: number;
  virusTotalEnabled: boolean;
  virusTotalApiKey?: string;
  scanTimeoutMs: number;
  maxFileSizeBytes: number;
}

/**
 * SECURITY: Malware scanning service for uploaded files
 *
 * Supports multiple scanning backends:
 * - ClamAV (local or clamd daemon)
 * - VirusTotal API (cloud-based)
 *
 * Files are scanned before being stored or processed.
 */
@Injectable()
export class MalwareScannerService {
  private readonly logger = new Logger(MalwareScannerService.name);
  private readonly config: ScannerConfig;

  constructor() {
    this.config = {
      enabled: process.env.MALWARE_SCAN_ENABLED === 'true',
      clamavEnabled: process.env.CLAMAV_ENABLED === 'true',
      clamavHost: process.env.CLAMAV_HOST || 'localhost',
      clamavPort: parseInt(process.env.CLAMAV_PORT || '3310', 10),
      virusTotalEnabled: process.env.VIRUSTOTAL_ENABLED === 'true',
      virusTotalApiKey: process.env.VIRUSTOTAL_API_KEY,
      scanTimeoutMs: parseInt(process.env.MALWARE_SCAN_TIMEOUT_MS || '30000', 10),
      maxFileSizeBytes: parseInt(process.env.MALWARE_SCAN_MAX_SIZE || '104857600', 10), // 100MB
    };

    if (this.config.enabled) {
      this.logger.log(
        `Malware scanning enabled: ClamAV=${this.config.clamavEnabled}, VirusTotal=${this.config.virusTotalEnabled}`
      );
    } else {
      this.logger.warn('SECURITY WARNING: Malware scanning is disabled');
    }
  }

  /**
   * Scan a file for malware
   *
   * @param fileBuffer - The file content to scan
   * @param filename - Original filename (for logging)
   * @returns Scan result
   * @throws BadRequestException if malware is detected
   */
  async scanFile(fileBuffer: Buffer, filename: string): Promise<MalwareScanResult> {
    if (!this.config.enabled) {
      return {
        clean: true,
        scanned: false,
        scannerUsed: 'disabled',
      };
    }

    // Check file size
    if (fileBuffer.length > this.config.maxFileSizeBytes) {
      this.logger.warn(`File too large for malware scan: ${filename} (${fileBuffer.length} bytes)`);
      return {
        clean: true,
        scanned: false,
        scannerUsed: 'disabled',
        error: 'File too large for scanning',
      };
    }

    const startTime = Date.now();
    const fileHash = this.calculateHash(fileBuffer);

    // Try ClamAV first (if enabled)
    if (this.config.clamavEnabled) {
      try {
        const result = await this.scanWithClamAV(fileBuffer, filename);
        result.scanDuration = Date.now() - startTime;
        result.fileHash = fileHash;

        if (!result.clean) {
          this.logger.error(`SECURITY: Malware detected in file ${filename}: ${result.threat}`);
          throw new BadRequestException(`File rejected: malware detected (${result.threat})`);
        }

        return result;
      } catch (error) {
        if (error instanceof BadRequestException) throw error;
        this.logger.error(`ClamAV scan failed: ${error.message}`);
        // Fall through to VirusTotal if available
      }
    }

    // Try VirusTotal (if enabled)
    if (this.config.virusTotalEnabled && this.config.virusTotalApiKey) {
      try {
        const result = await this.scanWithVirusTotal(fileBuffer, fileHash, filename);
        result.scanDuration = Date.now() - startTime;
        result.fileHash = fileHash;

        if (!result.clean) {
          this.logger.error(`SECURITY: Malware detected in file ${filename}: ${result.threat}`);
          throw new BadRequestException(`File rejected: malware detected (${result.threat})`);
        }

        return result;
      } catch (error) {
        if (error instanceof BadRequestException) throw error;
        this.logger.error(`VirusTotal scan failed: ${error.message}`);
      }
    }

    // No scanner available or all scanners failed
    this.logger.warn(`No malware scanner available for file: ${filename}`);
    return {
      clean: true,
      scanned: false,
      scannerUsed: 'disabled',
      fileHash,
      error: 'No scanner available',
    };
  }

  /**
   * Scan file using ClamAV (clamscan command or clamd daemon)
   */
  private async scanWithClamAV(fileBuffer: Buffer, _filename: string): Promise<MalwareScanResult> {
    return new Promise((resolve, reject) => {
      // Use clamscan with stdin for security (no temp files)
      const clamscan = spawn('clamscan', ['--no-summary', '--stdout', '-'], {
        timeout: this.config.scanTimeoutMs,
      });

      let stdout = '';
      let stderr = '';

      clamscan.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      clamscan.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      clamscan.on('close', (code) => {
        if (code === 0) {
          // Clean file
          resolve({
            clean: true,
            scanned: true,
            scannerUsed: 'clamav',
          });
        } else if (code === 1) {
          // Virus found
          const threatMatch = stdout.match(/: (.+) FOUND/);
          resolve({
            clean: false,
            scanned: true,
            scannerUsed: 'clamav',
            threat: threatMatch ? threatMatch[1] : 'Unknown threat',
          });
        } else {
          // Error
          reject(new Error(`ClamAV exited with code ${code}: ${stderr}`));
        }
      });

      clamscan.on('error', (error) => {
        reject(error);
      });

      // Write file buffer to stdin
      clamscan.stdin.write(fileBuffer);
      clamscan.stdin.end();
    });
  }

  /**
   * Scan file using VirusTotal API
   * Uses hash lookup first (faster), falls back to upload if needed
   */
  private async scanWithVirusTotal(
    fileBuffer: Buffer,
    fileHash: string,
    filename: string
  ): Promise<MalwareScanResult> {
    const apiKey = this.config.virusTotalApiKey!;
    const baseUrl = 'https://www.virustotal.com/api/v3';

    // First, check if hash is already known
    try {
      const hashResponse = await fetch(`${baseUrl}/files/${fileHash}`, {
        headers: { 'x-apikey': apiKey },
      });

      if (hashResponse.ok) {
        const data = await hashResponse.json();
        const stats = data.data?.attributes?.last_analysis_stats;

        if (stats) {
          const malicious = stats.malicious || 0;
          const suspicious = stats.suspicious || 0;

          if (malicious > 0 || suspicious > 0) {
            return {
              clean: false,
              scanned: true,
              scannerUsed: 'virustotal',
              threat: `Detected by ${malicious + suspicious} engines`,
            };
          }

          return {
            clean: true,
            scanned: true,
            scannerUsed: 'virustotal',
          };
        }
      }
    } catch (error) {
      this.logger.debug(`VirusTotal hash lookup failed: ${error.message}`);
    }

    // Hash not found, would need to upload file
    // Note: Uploading files exposes them to VirusTotal - may not be suitable for sensitive files
    this.logger.debug(
      `File ${filename} not in VirusTotal database (hash: ${fileHash}). ` +
        'Skipping upload to preserve confidentiality.'
    );

    return {
      clean: true,
      scanned: false,
      scannerUsed: 'virustotal',
      error: 'File not in database, upload skipped for confidentiality',
    };
  }

  /**
   * Calculate SHA-256 hash of file
   */
  private calculateHash(buffer: Buffer): string {
    return createHash('sha256').update(buffer).digest('hex');
  }

  /**
   * Check if scanning is enabled
   */
  isEnabled(): boolean {
    return this.config.enabled;
  }

  /**
   * Get scanner status for health checks
   */
  async getStatus(): Promise<{
    enabled: boolean;
    clamavAvailable: boolean;
    virusTotalAvailable: boolean;
  }> {
    let clamavAvailable = false;
    let virusTotalAvailable = false;

    if (this.config.clamavEnabled) {
      try {
        // Test ClamAV by checking version
        const result = await new Promise<boolean>((resolve) => {
          const proc = spawn('clamscan', ['--version'], { timeout: 5000 });
          proc.on('close', (code) => resolve(code === 0));
          proc.on('error', () => resolve(false));
        });
        clamavAvailable = result;
      } catch {
        clamavAvailable = false;
      }
    }

    if (this.config.virusTotalEnabled && this.config.virusTotalApiKey) {
      try {
        // Test VirusTotal API
        const response = await fetch('https://www.virustotal.com/api/v3/urls', {
          method: 'HEAD',
          headers: { 'x-apikey': this.config.virusTotalApiKey },
        });
        virusTotalAvailable = response.ok || response.status === 405;
      } catch {
        virusTotalAvailable = false;
      }
    }

    return {
      enabled: this.config.enabled,
      clamavAvailable,
      virusTotalAvailable,
    };
  }
}
